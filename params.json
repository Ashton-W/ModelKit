{"google":"","body":"#ModelKit\r\n\r\nModelKit is a simple to use model framework for Objective-C (Cocoa/iOS).  It allows you to write your model layer quickly and easily, managing persistence (local and network) for you.\r\n\r\nModelKit is under active development and, as such, should probably not be used for production.\r\n\r\n##About ModelKit\r\nBefore we jump into the how-to, it's important to understand what ModelKit is and isn't:\r\n\r\n###What Is It?\r\nModelKit was built to solve a few problems I consistently run into developing iPhone software.  Namely:\r\n\r\n* Persisting the model graph\r\n* Integrating with a backend web service or BaaS (Backend as a Service) like Parse\r\n* If using a backend, allowing the application to work offline.\r\n\r\nI do a lot of consulting and inherit a lot of projects that use CoreData to store all of the data they pull off their JSON based REST-esque API.  It is invariably a giant convoluted mess for what should be such a simple task.  Need to upgrade a CoreData schema?  Yeah, no thanks.\r\n\r\nModelKit could be considered CoreData-lite since it does most things that CoreData does.  It attempts to accomplish these things in the simplest way possible.  Therefore, it might not cover all the edge cases that CoreData does, nor does it ever intend to.\r\n\r\nThe other reason I needed something like ModelKit was to cover the holes in the iOS SDKs for certain BaaS services.  While these SDKs are generally good for simple things like saving game scores, the more complicated your needs get, the bigger the holes they develop and the more boilerplate you end up writing.  Since they typically aren't open sourced, you are left in the dark if you run head first into a wall.\r\n\r\n###What Does It Provide?\r\nModelKit gives you:\r\n\r\n* A framework for building mildly complicated object graphs\r\n* Persisting those graphs to local storage\r\n* Querying the graph\r\n* Tying the graph to a BaaS or your own custom backend REST API\r\n* User system (backend)\r\n* File uploads (backend)\r\n* Push notifications (backend)\r\n* Running custom backend code (backend)\r\n* Simplistic and optimistic syncing (backend)\r\n\r\n###How Do I Install It?\r\n\r\nI will write more in-depth installation notes in the future.\r\n\r\nFor now, just do a recursive check out of this git repo and check out the example application for pointers on getting it setup.\r\n\r\n\r\n\r\n##Working With Models\r\nCreating a model in ModelKit is as easy as you'd hope for:\r\n\r\n    #import \"MKitModel.h\"\r\n    \r\n    @interface CSMPAuthor : MKitModel\r\n    \r\n    @property (copy, nonatomic) NSString *name;\r\n    @property (copy, nonatomic) NSString *email;\r\n    @property (retain, nonatomic) NSDate *birthday;\r\n    @property (assign, nonatomic) NSInteger age;\r\n    @property (assign, nonatomic) BOOL displayEmail;\r\n    @property (copy, nonatomic) NSString *avatarURL;\r\n    \r\n    @end\r\n\r\nThat's all you have to do.  \r\n\r\nThere are, however, a few conventions you'll need to follow and a few concepts you'll want to understand before getting full use out of ModelKit.\r\n\r\n###Model Conventions\r\nModelKit makes heavy use of the Objective-C runtime to take care of all the boilerplate one would normally have to do to support serialization, persistence, etc.\r\n\r\n* Properties that are prefixed with **'model'** are ignored during serialization/de-serialization.  The **MKitModel** class has a number of properties with this prefix to manage state, etc.\r\n* Properties that reference other subclasses of **MKitModel** should not use **retain** but should use **assign** instead.  This is because ModelKit uses the concept of contexts which retain the models, but more on that later.\r\n* If a property of your objects is an array of **MKitModel** subclasses, you need to use the **MKitMutableModelArray** instead of **NSMutableArray** for the property.\r\n* All models have the following properties:\r\n  * **modelId** - A unique identifier for the object that model kit uses internally.\r\n  * **objectId** - A unique identifier for the object that is application specific.  If you are using a service like Parse, you typically will not set this directly, but let the service set it for you.  If you are using local persistence only, feel free to use this how you see fit.\r\n  * **createdAt** - The date the object was created\r\n  * **updatedAt** - The date the object was updated\r\n  \r\n###Model Serialization\r\nModels can be serialized/deserialized to NSDictionary, as well as to JSON strings.  This is all automatic and requires no configuration on your end.\r\n\r\nSerializing to a dictionary is as easy as:\r\n\r\n    CSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"001\"];\r\n    author.email=@\"jon@interfacelab.com\";\r\n    author.name=@\"Jon Gilkison\";\r\n    author.age=39;\r\n    author.displayEmail=YES;\r\n    author.avatarURL=@\"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n    \r\n    NSDictionary *serialized=[author serialize];\r\n    \r\nThe resulting dictionary would look like:\r\n\r\n\t{\r\n\t    createdAt = \"2012-10-29 06:44:01 +0000\";\r\n\t    model = Author;\r\n\t    modelId = AAAA-AAAA-AAAA-AAAA;\r\n\t    objectId = 001;\r\n\t    properties =     {\r\n\t        age = 39;\r\n\t        avatarURL = \"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n\t        birthday = \"<null>\";\r\n\t        displayEmail = 1;\r\n\t        email = \"jon@interfacelab.com\";\r\n\t        name = \"Jon Gilkison\";\r\n\t    };\r\n\t    updatedAt = \"2012-10-29 06:44:01 +0000\";\r\n\t}\r\n\r\nDeserializing back into an object is just as easy:\r\n\r\n    CSMPAuthor *author=[CSMPAuthor instanceWithDictionary:serialized];\r\n    \r\nThere is a caveat though.  If you look at the signature for the serialize method for MKitModel:\r\n\r\n\t-(id)serialize;\r\n\t\r\nYou see how it returns an **id**?  Serialize will actually return either an NSDictionary or an NSArray of NSDictionary depending on a few factors:\r\n\r\n* If your model contains model properties or arrays of models, serialize will return an array containing all of the different models it discovered while serializing.  The first dictionary in this array will be the original model you were serializing.  It does this to flatten out references and to allow circular references.  You can read more on that below.\r\n* If your model **does not** contain model properties or arrays of models, then serialize will return an NSDictionary.\r\n\r\n\r\n\r\n   \r\n###Model Serialization with JSON\r\nThis works exactly the same as serializing/deserializing to/from an NSDictionary with a few caveats.  JSON has no support for dates, binary data so ModelKit encodes the JSON slightly differently.\r\n\r\nUsing the above example, the serialized JSON would look like:\r\n\r\n\t{\r\n\t  \"createdAt\": {\r\n\t    \"__type\": \"Date\",\r\n\t    \"iso\": \"2012-10-29T13:50:03+0700\"\r\n\t  },\r\n\t  \"model\": \"Author\",\r\n\t  \"modelId\": \"AAAA-AAAA-AAAA-AAAA\",\r\n\t  \"objectId\": \"001\",\r\n\t  \"properties\": {\r\n\t    \"age\": 39,\r\n\t    \"avatarURL\": \"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\",\r\n\t    \"birthday\": null,\r\n\t    \"displayEmail\": 1,\r\n\t    \"email\": \"jon@interfacelab.com\",\r\n\t    \"name\": \"Jon Gilkison\"\r\n\t  },\r\n\t  \"updatedAt\": {\r\n\t    \"__type\": \"Date\",\r\n\t    \"iso\": \"2012-10-29T13:50:03+0700\"\r\n\t  }\r\n\t}\r\n\r\nAgain, as with normal serialization, if your model contains model properties or properties that are arrays of models, the JSON returned will be an array instead of an object.  Read the next section for more information as to why.\r\n\r\n###Referencing Other Models as Properties\r\nThis was mentioned in the caveats, but is worth mentioning in more detail.\r\n\r\nIt won't be uncommon that you'll want to reference other models as a property of your model.  For example, let's look at what a blog post model would look like:\r\n\r\n\t#import \"MKitModel.h\"\r\n\t#import \"CSMPAuthor.h\"\r\n\t\r\n\t@interface CSMPPost : MKitModel\r\n\t\r\n\t@property (assign, nonatomic) CSMPAuthor *author;\r\n\t@property (copy, nonatomic) NSString *title;\r\n\t@property (copy, nonatomic) NSString *body;\r\n\t\r\n\t@end\r\n\r\nNotice that CSMPAuthor model is a property, pointing to the author that wrote the post.  Pay close attention to the property access specifier though and notice that it is **assign** and not **retain**.  This is because there is a global context that retains all of the models you create.  We'll talk more about that in detail later, but it's important to know that these properties should always be **assign** otherwise you will leak objects like crazy.\r\n\r\nIf you are storing an array of models in your model, you'll want to use **MKitMutableModelArray**.  Because the context retains any models created, MKitMutableModelArray only retains weak references\r\n\r\n####What about circular references?\r\n\r\nNo problem.  When serializing, ModelKit tracks the models that it is serializing and creates pointers to models that it has already serialized.  Let's look at a very convoluted example:\r\n\r\n\t#import \"MKitModel.h\"\r\n\t\r\n\t@interface VeryConvolutedExample : MKitModel\r\n\t\r\n\t@property (assign, nonatomic) VeryConvolutedExample *circular;\r\n\t\r\n\t@end\r\n\t\r\nAnd then later in the code:\r\n\r\n\tVeryConvolutedExample *example=[VeryConvolutedExample instanceWithObjectId:@\"0001\"];\r\n\texample.circular=example;\r\n\t\r\n\tNSDictionary *serialized=[example serialize];\r\n\t\r\nNow, let's look at the dictionary we serialized:\r\n\r\n\t{\r\n\t    createdAt = \"2012-10-29 07:04:08 +0000\";\r\n\t    model = VeryConvolutedExample;\r\n\t    modelId = AAAA-AAAA-AAAA-AAAA;\r\n\t    objectId = 0001;\r\n\t    properties =     {\r\n\t        circular =         {\r\n\t            \"__type\" = ModelPointer;\r\n\t            model = VeryConvolutedExample;\r\n\t            objectId = 0001;\r\n\t        };\r\n\t    };\r\n\t    updatedAt = \"2012-10-29 07:04:08 +0000\";\r\n\t}\r\n\r\nHere's the JSON example:\r\n\r\n\t{\r\n\t  \"createdAt\": {\r\n\t    \"__type\": \"Date\",\r\n\t    \"iso\": \"2012-10-29T14:04:58+0700\"\r\n\t  },\r\n\t  \"model\": \"VeryConvolutedExample\",\r\n\t  \"modelId\": \"AAAA-AAAA-AAAA-AAAA\",\r\n\t  \"objectId\": \"0001\",\r\n\t  \"properties\": {\r\n\t    \"circular\": {\r\n\t      \"__type\": \"ModelPointer\",\r\n\t      \"model\": \"VeryConvolutedExample\",\r\n\t      \"objectId\": \"0001\"\r\n\t    }\r\n\t  },\r\n\t  \"updatedAt\": {\r\n\t    \"__type\": \"Date\",\r\n\t    \"iso\": \"2012-10-29T14:04:58+0700\"\r\n\t  }\r\n\t}\r\n\r\nThe **ModelPointer** type tells the serializer/deserializer that this a pointer to another object that has already been serialized in the same dictionary.  ModelKit will automatically take care of these references for you.\r\n\r\nSo circular reference your heart out, just make sure your properties are **assign** and not **retain**.\r\n\r\n###Getting Properties and/or Changed Properties\r\nYou may have the case where your serialization format is different than how ModelKit serializes by default.  You can easily grab the properties of any object as a dictionary, even grabbing only the properties that have been changed.  Let's look at an example:\r\n\r\n    CSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"001\"];\r\n    author.email=@\"jon@interfacelab.com\";\r\n    author.name=@\"Jon Gilkison\";\r\n    author.age=39;\r\n    author.displayEmail=YES;\r\n    author.avatarURL=@\"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n    \r\n    NSDictionary *properties=[author properties];\r\n\r\nHere we've grabbed all of the properties of the object.  Here's what that dictionary will look like:\r\n\r\n\t{\r\n\t    email = \"jon@interfacelab.com\";\r\n\t    name = \"Jon Gilkison\";\r\n\t    age = 39;\r\n\t    displayEmail = YES;\r\n\t    avatarURL = @\"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n\t}\r\n\r\nNow what about the case where we only want the properties that have been changed?  Nearly the same thing:\r\n\r\n    CSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"001\"];  // exists already\r\n    \r\n    // going to change the email and name only\r\n    author.email=@\"jon@interfacelab.com\";\r\n    author.name=@\"Jon Gilkison\";\r\n    \r\n    NSDictionary *changes=author.modelChanges;\r\n\r\nAnd the dictionary:\r\n\r\n\t{\r\n\t    email = \"jon@interfacelab.com\";\r\n\t    name = \"Jon Gilkison\";\r\n\t}\r\n\r\nYou can reset the changes by calling **resetChanges** on the model:\r\n\r\n\t[author resetChanges];\r\n\t\r\n###Model Property Change Notifications\r\nWhenever a property of a model is changed, the model will broadcast a notification: **MKitModelPropertyChangedNotification**.  You can the add observers for this notification and update your UI as the model is changed:\r\n\r\n\t-(void)viewDidLoad\r\n\t{\r\n\t\tself.author=[CSMPAuthor instanceWithId:@\"001\"];\t\r\n\t    [[NSNotificationCenter defaultCenter] addObserver:self\r\n\t                                             selector:@selector(authorChanged:)\r\n\t                                                 name:MKitModelPropertyChangedNotification\r\n\t                                               object:self.author];\r\n\t}\r\n\t\r\n\t-(void)viewDidUnload\r\n\t{\r\n\t\t// Don't forget to unregister!\r\n\t    [[NSNotificationCenter defaultCenter] removeObserver:self];\r\n\t}\r\n\t\r\n\t-(void)authorChanged:(NSNotification *)notification\r\n\t{\r\n\t\tif (notification.userInfo==nil)\r\n\t\t{\r\n\t\t\tNSLog(@\"Entire model changed!\");\r\n\t\t\t\r\n\t\t\t[self.author.modelChanges enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\r\n\t\t        NSLog(@\"%@ = %@\",key,obj);\r\n\t\t    }];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tid prop=notification.userInfo[@\"keyPath\"];\r\n\t\t\tid oldVal=notification.userInfo[NSKeyValueChangeOldKey];\r\n\t\t\tid newVal=notification.userInfo[NSKeyValueChangeNewKey];\r\n\t\t\tNSLog(@\"Property: %@  Old: %@   New: %@\", prop,oldVal,newVal);\r\n\t\t}\r\n\t}\r\n\t\r\nWhat if you are changing a whole slew of properties at once?  You can suspend notifications until your finished by calling **beginChanges** and **endChanges** on the model:\r\n\r\n\t-(void)viewDidLoad\r\n\t{\r\n\t\tself.author=[CSMPAuthor instanceWithId:@\"001\"];\t\r\n\t    [[NSNotificationCenter defaultCenter] addObserver:self\r\n\t                                             selector:@selector(authorChanged:)\r\n\t                                                 name:MKitModelPropertyChangedNotification\r\n\t                                               object:self.author];\r\n\t}\r\n\t\r\n\t-(void)viewDidUnload\r\n\t{\r\n\t\t// Don't forget to unregister!\r\n\t    [[NSNotificationCenter defaultCenter] removeObserver:self];\r\n\t}\r\n\t\r\n\t-(void)changeLots:(id)sender\r\n\t{\r\n\t\t[self.author beginChanges];\r\n\r\n\t\tself.author.email=\"whutwhut@interfacelab.com\";\r\n\t\tself.author.name=\"Joe Blow\";\r\n\t\tself.author.age=29;\r\n\t\tself.author.displayEmail=NO;\r\n\t\t\r\n\t\t[self.author endChanges];\r\n\t}\r\n\t\r\n\t-(void)authorChanged:(NSNotification *)notification\r\n\t{\r\n\t\tif (notification.userInfo==nil)\r\n\t\t{\r\n\t\t\tNSLog(@\"Entire model changed!\");\r\n\t\t\t\r\n\t\t\t[self.author.modelChanges enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\r\n\t\t        NSLog(@\"%@ = %@\",key,obj);\r\n\t\t    }];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tid prop=notification.userInfo[@\"keyPath\"];\r\n\t\t\tid oldVal=notification.userInfo[NSKeyValueChangeOldKey];\r\n\t\t\tid newVal=notification.userInfo[NSKeyValueChangeNewKey];\r\n\t\t\tNSLog(@\"Property: %@  Old: %@   New: %@\", prop,oldVal,newVal);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n##Contexts\r\nModelKit has a global context that stores all models you create, allowing your application access to all instances regardless of where in your code it's accessing it from.  This provides a variety of benefits:\r\n\r\n* No duplication of object instances\r\n* You can persist and load contexts to/from file\r\n* You don't have to worry about managing memory as it relates to your models\r\n* Global access to all model instances\r\n\r\nNormally, you will never need to worry about contexts, but will need to follow some simple guidelines:\r\n\r\n* Model instances you create should be auto released\r\n\r\nOk, 1 simple guideline.  So that's easy, right?\r\n\r\nLet's look at some examples:\r\n\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n    \tCSMPAuthor *author=[[CSMPAuthor alloc] init];\r\n    \t// do some stuff.\r\n\t}\r\n\r\nIn this example, we just leaked an object because we didn't autorelease it.  This is the proper way:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n    \tCSMPAuthor *author=[[[CSMPAuthor alloc] init] autorelease];\r\n    \t// do some stuff.\r\n\t}\r\n\r\nYou might think that because we're autoreleasing the object that it will be released once we exit this method.  This is not the case as the model context retains all models created.  So, in a way, this model could be considered leaked if it is not your intention to ever use it again.\r\n\r\nIf we wanted to release the model the proper way to write this would be:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n    \tCSMPAuthor *author=[[[CSMPAuthor alloc] init] autorelease];\r\n    \t// do some stuff.\r\n    \t[author removeFromContext];\r\n\t}\r\n\r\nCalling **removeFromContext** insures that the model is removed from the context.\r\n\r\n###Fetching Models\r\n\r\nYou can fetch a model at a later stage by requesting it from the context again.  You can do this using the model's **modelId** or by its **objectId**.\r\n\r\nTo do this \"manually\" using the context:\r\n\r\n\t-(void)createModelAction:(id)sender\r\n\t{\r\n    \tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"0001\"]; // this is already auto-released\r\n    \tauthor.name=\"Jon Gilkison\";\r\n    \tauthor.email=\"jon@interfacelab.com\";\r\n\t}\r\n\t\r\n\t-(void)fetchModelAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=(CSMPAuthor *)[[MKitModelContext current] modelForObjectId:@\"0001\" andClass:[CSMPAuthor class]];\r\n\t}\r\n\t\r\nNow, you're never going to do it this way.  The better way is:\r\n\t\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n    \tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"0001\"]; // this is already auto-released\r\n    \tauthor.name=\"Jon Gilkison\";\r\n    \tauthor.email=\"jon@interfacelab.com\";\r\n\t}\r\n\t\r\n\t-(void)someOtherAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"0001\"];\r\n\t\tif ([author.name isEqualToString:@\"Jon Gilkison\"])\r\n\t\t\tNSLog(@\"Same instance.\");\r\n\t}\r\n\t\r\nThe **instanceWithObjectId** and **instanceWithModelId** class methods always first check the context for an existing model with matching id and return that instance instead of creating a new one.  If it can't find one, it'll create a new instance, add it to the context and then return it.\r\n\r\n###Removing a Model From The Context\r\nRemoving a model from a context is this simple:\r\n\r\n    CSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"0001\"];\r\n    [author removeFromContext];\r\n   \r\nYou'll need to be careful here because if any object has this object as a property, because it's a weak reference, you'll crash your application.\r\n   \r\n###Multiple Contexts\r\nThere might be conditions where you want to create a temporary context, perhaps to load a bunch of temporary objects for processing.\r\n\r\n\t// Push a new context onto the context stack\r\n    [MKitModelContext push]; \r\n    \r\n    // Load up a bunch of objects…\r\n    for(int i=0; i<100; i++)\r\n    \t[CSMPAuthor instanceWithObjectId:[NSString stringWithFormat:@\"%d\",i]];\r\n    \t\r\n    // Do our processing\r\n    \r\n    // Dump the context and it's associated objects\r\n    [MKitModelContext pop];\r\n    \r\nIn this example, we pushed a new context onto the context stack, created a bunch of objects and then popped the context off.\r\n\r\nIn a more complicated example, we can push a new context onto a stack, retain a reference to it, pop it off and then push it onto the stack again later:\r\n\r\n\tMKitModelContext *newContext=[[MKitModelContext push] retain];\r\n\t    \r\n    // Load up a bunch of objects…\r\n    for(int i=0; i<100; i++)\r\n    \t[CSMPAuthor instanceWithObjectId:[NSString stringWithFormat:@\"%d\",i]];\r\n    \t\r\n    // Do our processing\r\n    \r\n    // Dump the context and it's associated objects\r\n    [MKitModelContext pop];\r\n    \r\n    // Do some other stuff\r\n    \r\n    // Restore our context:\r\n    [newContext activate];\r\n    \r\n    // Create some more objects ...\r\n    for(int i=0; i<100; i++)\r\n    \t[CSMPAuthor instanceWithObjectId:[NSString stringWithFormat:@\"%d\",i]];\r\n    \t\r\n    // Deactivate the context\r\n    [newContext deactivate];\r\n    \r\n    // Release it to destroy it\r\n    [newContext release];\r\n    \r\nIt's important to know that there can only be one context active at a time.  If a background thread is creating objects at the same time as the above code is running, those objects created in the background will exist in the current thread.  This is a big TODO.\r\n\r\n###Persisting Contexts\r\nYou can store an entire context to file, as well as restore it at a later time:\r\n\r\n\t[[MKitModelContext current] writeToFile:@\"/tmp/persisted.plist\" error:nil];\r\n\t\r\nYou can then restore it:\r\n\r\n\t[[MKitModelContext current] loadFromFile:@\"/tmp/persisted.plist\" error:nil];\r\n\t\r\nThis makes it super simple to save your entire object graph on application exit and restore it the exact same point when you launch the application again.\r\n\r\n###Clearing Contexts\r\nYou can reset the entire context system:\r\n\r\n\t[MKitModelContext clearAllContexts];\r\n\t\r\nOr, just clear one of them:\r\n\r\n\t[[MKitModelContext current] clear];\r\n\t\r\nThis will remove all objects from the context, releasing them.\r\n\r\n###No Context Models\r\nThere will definitely be times when you don't want your model to ever be added to a context.  This is simple to achieve by adding the MKitNoContext protocol to your model:\r\n\r\n    #import \"MKitModel.h\"\r\n    \r\n    @interface CSMPAuthor : MKitModel<MKitNoContext>\r\n    \r\n    @property (copy, nonatomic) NSString *name;\r\n    @property (copy, nonatomic) NSString *email;\r\n    @property (retain, nonatomic) NSDate *birthday;\r\n    @property (assign, nonatomic) NSInteger age;\r\n    @property (assign, nonatomic) BOOL displayEmail;\r\n    @property (copy, nonatomic) NSString *avatarURL;\r\n    \r\n    @end\r\n\r\nAny instances of this object will not be added to the context ever, unless you do so manually:\r\n\r\n\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"001\"];\r\n\t[author addToContext];\r\n\t\r\n###Context Information\r\nAll contexts have two properties that tell you information about it:\r\n\r\n* **contextSize** The size of the context in bytes.  This is a rough guesstimate and should not be relied on as fact.\r\n* **contextCount** The number of objects currently stored in the context\r\n\r\nYou can use it:\r\n\r\n\tNSLog(@\"Context Size: %d\",[MKModelContext current].contextSize);\r\n\tNSLog(@\"Context Count: %d\",[MKModelContext current].contextCount);\r\n\t\r\n## Model Querying\r\nModelKit provides an interface for querying both the context and your backend services for models.  Both methods are exactly the same, though some caveats for backend services exist and will be discussed further in the documentation.\r\n\r\nLet's take a look:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tMKitModelQuery *query=[CSMPAuthor query];\r\n\t\t\r\n\t\t// Let's find all authors between the ages of 24 to 35\r\n\t\t[query key:@\"age\" condition:KeyBetween value:@[@(24),@(35)]];\r\n\t\t\r\n\t\tNSDictionary *result=[query execute:nil];\r\n\t\tNSArray *found=[result objectForKey:MKitQueryResultKey];\r\n\t\tfor(CSMPAuthor *author in found)\r\n\t\t\tNSLog(@\"Author %@ is %d\",author.name,author.age);\r\n\t}\r\n\t\r\nThat's a pretty simple example, but we can do more complicated queries using different conditions.  Below is a list of conditions that the query supports:\r\n\r\nCondition|Meaning\r\n---------|---------\r\nKeyEquals | == \r\nKeyNotEqual | !=\r\nKeyGreaterThanEqual | >= \r\nKeyGreaterThan | >\r\nKeyLessThan | <\r\nKeyLessThanEqual | <= \r\nKeyIn | The value for the key is in an array of values\r\nKeyNotIn | The value for the key is not in an array of values\r\nKeyExists | The key value is not nil\r\nKeyNotExist | The key value is nil\r\nKeyWithin | The key value is within the range of two values\r\nKeyBeginsWith | The key value begins with a string value\r\nKeyEndsWith | The key value ends with a string value\r\nKeyLike | The key value contains the string\r\n\r\nQueries are always AND and subqueries are not supported.  Support for OR and subqueries is planned however.\r\n\r\n## Tying to Backend Services\r\nModelKit was originally designed to replace Parse.com's iOS SDK.  Therefore, a primary goal of this framework is not only model persistence/management, but tying those models to a backend, either a BaaS like Parse or Kinvey, or your own custom REST solution.\r\n\r\nCurrently, ModelKit supports Parse through their REST API.\r\n\r\n### Setting Up The Service\r\nSetting up the service is pretty simple.  In the code for your application launch:\r\n\r\n\t[MKitServiceManager setupService:@\"Parse\" withKeys:@{@\"AppID\":PARSE_APP_ID,@\"RestKey\":PARSE_REST_KEY}];\r\n    \r\n\r\n\r\n### Making Your Models Usable With The Service\r\nTo use your models with Parse, simply make them subclasses of MKitParseModel:\r\n\r\n\t@interface CSMPAuthor : MKitParseModel\r\n    \r\n    @property (copy, nonatomic) NSString *name;\r\n    @property (copy, nonatomic) NSString *email;\r\n    @property (retain, nonatomic) NSDate *birthday;\r\n    @property (assign, nonatomic) NSInteger age;\r\n    @property (assign, nonatomic) BOOL displayEmail;\r\n    @property (copy, nonatomic) NSString *avatarURL;\r\n    \r\n    @end\r\n\r\nIf you were to use this straight away, you'd notice in the Parse data browser that your classes are named **CSMPAuthor**.  If this is not what you want, you can change this behavior by doing the following in your implementation:\r\n\r\n\t@implementation CSMPAuthor\r\n\t\r\n\t+(void)load\r\n\t{\r\n\t    [self register];\r\n\t}\r\n\t\r\n\t+(NSString *)modelName\r\n\t{\r\n\t    return @\"Author\";\r\n\t}\r\n\t\r\n\t@end\r\n\r\nTwo things are happening here.  When you override **+(NSString \\*)modelName** you are telling the system the name of the class you want to use for Parse.  With this overridden, after you save your model, in the Parse data browser you would then see a class **Author** instead of **CSMPAuthor**.\r\n\r\nIf you do override **+(NSString \\*)modelName**, you'll also need to override **+(void)load** and call **[self register];** to make sure that your custom model name is registered with your model class so that when data returned from Parse is -well- parsed, that the correct model types are created.\r\n\r\n### Saving and Updating\r\nSaving models to Parse is as simple as can be.  You have two choices, synchronous and asynchronous.  Let's look at synchronous first:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instance];\r\n\t\tauthor.email=@\"jon@interfacelab.com\";\r\n\t    author.name=@\"Jon Gilkison\";\r\n\t    author.age=39;\r\n\t    author.displayEmail=YES;\r\n\t    author.avatarURL=@\"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n\t    \r\n\t    NSError *error=nil;\r\n\t    if (![author save:&error])\r\n\t    \tNSLog(@\"Oops: %@\",error);\r\n\t    else\r\n\t    \tNSLog(@\"Saved!\");\r\n\t}\r\n\t\r\nThat was easy, but there is a problem.  Synchronous saving will block the thread while it waits for the request to be sent to Parse and then wait for Parse to send a response.  This is fine if you're running this in a background thread, but in your main thread, this will block your UI and make your app unresponsive.\r\n\r\nAsynchronous is better:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t    CSMPAuthor *author=[CSMPAuthor instance];\r\n\t    author.email=@\"jon@interfacelab.com\";\r\n\t    author.name=@\"Jon Gilkison\";\r\n\t    author.age=39;\r\n\t    author.displayEmail=YES;\r\n\t    author.avatarURL=@\"https://secure.gravatar.com/avatar/819b112459b48de1e3ea08128b8e5479\";\r\n\t    \r\n\t    [author saveInBackground:^(BOOL succeeded, NSError *error) {\r\n\t       if (!succeeded)\r\n\t           NSLog(@\"OOPS %@\",error);\r\n\t        else\r\n\t            NSLog(@\"Saved!\");\r\n\t    }];\r\n\t}\r\n\r\nThe save will now happen in the background and your main thread can keep on trucking.\r\n\r\nWhat about updating?  The **save** method creates and updates automatically, so you'll call it whether you are creating a new object or updating an existing one.\r\n\r\nOne thing to note is that if your model has model properties or a property that's an array of models, those models will automatically be saved or updated if needed, no need to do it one by one yourself.\r\n\r\n### Deleting\r\nThis works the same way as saving.  Synchronously:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"as322DdddzJ\"];\r\n\t    \r\n\t    NSError *error=nil;\r\n\t\tif (![author delete:&error])\r\n\t    \tNSLog(@\"Oops: %@\",error);\r\n\t    else\r\n\t    \tNSLog(@\"Deleted!\");\r\n\t}\r\n\r\n\r\nAsynchronously:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"as322DdddzJ\"];\r\n\t    \r\n\t    [author deleteInBackground:^(BOOL succeeded, NSError *error) {\r\n\t       if (!succeeded)\r\n\t           NSLog(@\"OOPS %@\",error);\r\n\t        else\r\n\t            NSLog(@\"Deleted!\");\r\n\t    }];\r\n\t}\r\n\r\n### Fetching\r\nThere will be instances where models don't have all their data from Parse.  This could be the result from a query or by creating an instance with a known parse **objectId**.  To know if you need to fetch this data, you can inspect the **modelState** property and if it's equal to **ModelStateNeedsData** then that is a sure sign you need to get to fetching.\r\n\r\nAnd just like saving and deleting:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"as322DdddzJ\"];\r\n\t    \r\n\t    if (author.modelState==ModelStateNeedsData)\r\n\t    {\r\n\t    \tNSError *error=nil;\r\n\t\t\tif (![author fetch:&error])\r\n\t    \t\tNSLog(@\"Oops: %@\",error);\r\n\t    \telse\r\n\t    \t\tNSLog(@\"fetched!\");\r\n\t    }\r\n\t}\r\n\r\n\r\nAsynchronously:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tCSMPAuthor *author=[CSMPAuthor instanceWithObjectId:@\"as322DdddzJ\"];\r\n\t    \r\n\t    if (author.modelState==ModelStateNeedsData)\r\n\t    {\r\n\t\t    [author fetchInBackground:^(BOOL succeeded, NSError *error) {\r\n\t\t       if (!succeeded)\r\n\t\t           NSLog(@\"OOPS %@\",error);\r\n\t\t        else\r\n\t\t            NSLog(@\"Fetched!\");\r\n\t\t    }];\r\n\t\t}\r\n\t}\r\n\r\n\r\n### Querying\r\nQuerying works exactly the same as described in the section above, except that instead of using NSPredicates to query the context, you are generating web requests to Parse.  Otherwise, the interface and usage is exactly the same.\r\n\r\nBut what if you want to query the context?  Maybe your user doesn't have an internet connection or you just want to search locally.  **MKServiceModel**, which **MKParseModel** subclasses, has a static class method called **contextQuery**.  Using this will query the context instead of the backend service:\r\n\r\n\t-(void)someAction:(id)sender\r\n\t{\r\n\t\tMKitModelQuery *query=[CSMPAuthor contextQuery];\r\n\t\t\r\n\t\t// Let's find all authors between the ages of 24 to 35\r\n\t\t[query key:@\"age\" condition:KeyBetween value:@[@(24),@(35)]];\r\n\t\t\r\n\t\tNSDictionary *result=[query execute:nil];\r\n\t\tNSArray *found=[result objectForKey:MKitQueryResultKey];\r\n\t\tfor(CSMPAuthor *author in found)\r\n\t\t\tNSLog(@\"Author %@ is %d\",author.name,author.age);\r\n\t}\r\n\r\n\r\n### Users\r\n\r\nModelKit provides a working User model out of the box.  Note the user only works with a backend service because it wouldn't make any sense if your data was always local.  Duh.\r\n\r\nIf you are familiar with **PFUser** from the Parse iOS SDK, it works almost identically, except that you can subclass it and add your own properties to it.\r\n\r\nThe Parse user class is **MKitParseUser**, which is a subclass of **MKitParseModel** that implements the **MKitServiceUser** protocol.  Because it's a model, everything you can do with that you can do with **MKitParseModel**.\r\n\r\n#### Determining If The Current User Is Logged In\r\nYou can check to see if the current user is logged in by calling the **currentUser** static method:\r\n\r\n\tif ([MKitParseUser currentUser])\r\n\t{\r\n\t\t// Logged In!\r\n\t}\r\n\r\n\r\n\r\n#### Signing Up\r\nSigning up your users for your application is straight forward.  As with saving/deleting/fetching, it can be done synchronously or asynchronously depending on your needs.  Synchronously:\r\n\r\n\r\n\t-(void)signUpTouched:(id)sender\r\n\t{\r\n\t    NSError *error=nil;\r\n\t    BOOL result=[MKitParseUser signUpWithUserName:@\"bob\" email:@\"bob@somewhere.com\" password:@\"password\" error:&error];\r\n\t    if (!result)\r\n\t        NSLog(@\"ERROR: %@\",error);\r\n    }\r\n    \r\nAsynchronously:\r\n\r\n\t-(void)signUpTouched:(id)sender\r\n\t{\r\n\t\t[MKitParseUser signUpInBackgroundWithUserName:@\"bob\"\r\n\t\t                                            email:@\"bob@somewhere.com\"\"\r\n\t\t                                         password:@\"password\"\r\n\t\t                                      resultBlock:^(id object, NSError *error) {\r\n\t\t                                          if (error)\r\n\t\t                                              NSLog(@\"ERROR: %@\", error);\r\n\t\t                                      }];\r\n\t}\r\n\t\r\nOnce the user is signed up, that user will be logged in.  There is no need to log them in.\r\n\r\n#### Logging In\r\n\r\n\t-(void)signUpTouched:(id)sender\r\n\t{\r\n\t    [MKitParseUser logInInBackgroundWithUserName:@\"bob\"\r\n\t                                         password:@\"password\"\r\n\t                                      resultBlock:^(id object, NSError *error) {\r\n\t                                         if (error)\r\n\t                                        \t  NSLog(@\"ERROR: %@\",error);\r\n\t                                      }];\r\n\t}\r\n\t\r\nLogging in will keep the user logged in forever, the user session never expires.\r\n\r\n#### Logging Out\r\n\r\n\r\n\t-(void)logOutTouched:(id)sender\r\n\t{\r\n\t\t[[MKitParseUser currentUser] logOut];\r\n\t}\r\n\t\r\n\r\n#### Forgotten Password?\r\n\r\n\t-(void)forgotPasswordTouched:(id)sender\r\n\t{\r\n\t    [MKitParseUser requestPasswordResetInBackgroundForEmail:@\"bob@somewhere.com\"\r\n                                                    resultBlock:^(BOOL succeeded, NSError *error) {\r\n                                                        if (error)\r\n                                                            NSLog(@\"ERROR: %@\",error);\r\n                                           }];\r\n\r\n\t}\r\n\r\n\r\n\r\n### Files\r\n\r\nModelKit also provides a mechanism to upload files to your backend and associating those files with your users.  Like users, this feature requires a backend integration and is not available for local models.\r\n\r\n**MKitParseFile** subclasses **MKitServiceFile**, but it is important to note that it is not a subclass of any model and should not be treated like a model.  In other words, you cannot add properties to it.  But what if that is what you want to do?  For example, let's say you want to model a Photograph.  You would create a Photograph model and have MKitParseFile as property of that model that points to the file.  Read more about this below because there are some **important** caveats.\r\n\r\n#### Uploading Files\r\nUploading files is very simple and supports synchronous and asynchronous operation.  I will only demonstrate asynchronous:\r\n\r\n    MKitParseFile *p=[MKitParseFile fileWithFile:[[NSBundle mainBundle] pathForResource:@\"image2\" ofType:@\"jpeg\"]];\r\n    [p saveInBackgroundWithProgress:^(float progress) {\r\n        NSLog(@\"%f\",progress);\r\n    }\r\n                        resultBlock:^(BOOL succeeded, NSError *error) {\r\n                            if (succeeded)\r\n                                NSLog(@\"%@\",p.url);\r\n                            else\r\n                                NSLog(@\"ERORR: %@\",error);\r\n                        }];\r\n\r\nYou are not limited to uploading an existing file, you can upload an NSData instance as well.  This is a convoluted example, but you get the point:\r\n\r\n\r\n    NSData *data=[NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"image2\" ofType:@\"jpeg\"]\r\n                                        options:NSDataReadingMappedAlways\r\n                                          error:nil];\r\n    MKitParseFile *p=[MKitParseFile fileWithData:data name:@\"image2.jpeg\" contentType:@\"image/jpeg\"];\r\n    [p saveInBackgroundWithProgress:^(float progress) {\r\n        NSLog(@\"%f\",progress);\r\n    }\r\n                        resultBlock:^(BOOL succeeded, NSError *error) {\r\n                            if (succeeded)\r\n                                NSLog(@\"%@\",p.url);\r\n                            else\r\n                                NSLog(@\"ERORR: %@\",error);\r\n                        }];\r\n                        \r\nOnce the upload has successfully completed, the **url** and **name** properties will be populated with values returned from the server.  **url** will be a valid URL to the uploaded resource and **name** will contain the backend's unique name for the file.\r\n\r\n\r\n#### Uploading Batches\r\nModelKit provides the **MKitMutableFileArray** class which allows you to easily do batch uploading (and is useful as an array of files property on a model).  It's a subclass of **NSMutableArray** so you can cast it up the chain no problem.  Here's an example of a batch upload:\r\n\r\n    MKitMutableFileArray *files=[MKitMutableFileArray array];\r\n    \r\n    // Add 10 files to the array to upload\r\n    for(int i=0; i<10; i++)\r\n        [files addObject:[MKitParseFile fileWithFile:[[NSBundle mainBundle] pathForResource:@\"image2\" ofType:@\"jpeg\"]]];\r\n    \r\n    [files uploadInBackgroundWithProgress:^(NSInteger current, NSInteger total, float currentProgress, float totalProgress) {\r\n        NSLog(@\"File %d of %d - Progress %f - Total Progress %f\",current,total, currentProgress, totalProgress);\r\n    } resultBlock:^(BOOL succeeded, NSError *error) {\r\n        NSLog(@\"Finished\");\r\n    }];\r\n\r\n\r\n\r\n\r\n#### Associating With Models\r\n\r\nYou can use **MKitParseFile** as a property of an model, but there are some things you must know:\r\n\r\n* You must **retain** the property, not **assign** as you would do for a model property\r\n* The file must be uploaded to the backend before saving your model to the backend.  Failure to do so will raise an exception.\r\n\r\nWith those two things in mind, here's a model with a file as a property:\r\n\r\n\t#import \"ModelKit.h\"\r\n    \r\n    @interface CSMPPhoto : MKitParseModel\r\n    \r\n    @property (assign, nonatomic) MKitParseUser *owner;\r\n\t@property (retain, nonatomic) MKitParseFile *photo;\r\n\t    \r\n    @end\r\n\r\n\r\n#### Deleting Files\r\nLike models, you can simply call **delete** on the file to delete it.  Unless you are using Parse.  If you are using Parse, Parse requires you to use the MasterKey to delete files from the backend.  Therefore, it is not possible to delete them with ModelKit.\r\n\r\nHowever, if you delete a model that has a file as a property, you can clean out \"unused\" files in the Parse data dashboard.\r\n\r\n### GeoPoints\r\nTBD\r\n\r\n### Calling Backend Code\r\nTBD\r\n\r\n### Offline and Syncing\r\nTBD\r\n\r\n","tagline":"A better model framework for Objective-C","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Modelkit"}